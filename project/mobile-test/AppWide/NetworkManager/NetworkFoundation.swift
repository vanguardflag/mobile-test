//
//  NetworkFoundation.swift
//
//
//  Created by Jalal Najafi.
//  Copyright Â© 2018  . All rights reserved.
//

import Foundation
import Alamofire
import PromiseKit
import Reachability

protocol NetworkUtilities {
    func get(fromURL: String,
             parameters: Parameters?) -> Promise<Data>
    func post(toURL: String?,
              parameters: Parameters?) -> Promise<Data>
    func put(toURL: String,
             parameters: Parameters?) -> Promise<Data>
    func delete(fromURL: String,
                parameters: Parameters?) -> Promise<Data>
    func uploadFile(toURL url: String,
                    file: Data,
                    name: String,
                    extention: String,
                    mimeType: String,
                    parameters: Parameters?) -> Promise<Data>
    func deleteWithUrlParameters(fromURL url: String, parameters: Parameters?) -> Promise<Data>
    func getNewTransactionId()->CUnsignedLongLong 
}
class  HttpGateway: NetworkConfiguration, NetworkUtilities {
    
    
 
    
    func get(fromURL url: String, parameters: Parameters?) -> Promise<Data> {
        guard NetworkReachabilityManager()?.isReachable ?? false else {
            return Promise(error: Errors.Remote.noNetworkConnectivity)
        }
        
        let url = baseUrl + url
        return session.request(url,
                               method: .get,
                               parameters: parameters?.dictionary,
                               encoding: URLEncoding.default,
                               headers: header)
            .validate(validate(_:_:_:))
            .responseData()
    }
    
    func post(toURL url: String?, parameters: Parameters?) -> Promise<Data> {
        guard NetworkReachabilityManager()?.isReachable ?? false else {
            return Promise(error: Errors.Remote.noNetworkConnectivity)
        }
        let url = baseUrl + url!
  
  
        return session.request(url,
                               method: .post,
                               parameters: parameters?.dictionary,
                               encoding: JSONEncoding.default,
                               headers: header)
            .validate(validate(_:_:_:))
            .responseData()
       

    }
    func postWithUrlParameters(toURL url: String, parameters: Parameters?) -> Promise<Data> {
        guard NetworkReachabilityManager()?.isReachable ?? false else {
            return Promise(error: Errors.Remote.noNetworkConnectivity)
        }
        let url = baseUrl + url
        return session.request(url,
                               method: .post,
                               parameters: parameters?.dictionary,
                               encoding: URLEncoding(destination: .queryString),
                               headers: header)
            .validate(validate(_:_:_:))
            .responseData()
        
    }
    
    func put(toURL url: String, parameters: Parameters?) -> Promise<Data> {
        guard NetworkReachabilityManager()?.isReachable ?? false else {
            return Promise(error: Errors.Remote.noNetworkConnectivity)
        }
        let url = baseUrl + url
        return session.request(url,
                               method: .put,
                               parameters: parameters?.dictionary,
                               encoding: JSONEncoding.default,
                               headers: header)
            .validate(validate(_:_:_:))
            .responseData()
    }
    func putWithUrlParameters(toURL url: String, parameters: Parameters?) -> Promise<Data> {
        guard NetworkReachabilityManager()?.isReachable ?? false else {
            return Promise(error: Errors.Remote.noNetworkConnectivity)
        }
        let url = baseUrl + url
        return session.request(url,
                               method: .put,
                               parameters: parameters?.dictionary,
                               encoding: URLEncoding(destination: .queryString),
                               headers: header)
            .validate(validate(_:_:_:))
            .responseData()
    }
    
    func delete(fromURL url: String, parameters: Parameters?) -> Promise<Data> {
        guard NetworkReachabilityManager()?.isReachable ?? false else {
            return Promise(error: Errors.Remote.noNetworkConnectivity)
        }
        let url = baseUrl + url
        return session.request(url,
                               method: .delete,
                               parameters: parameters?.dictionary,
                               encoding: JSONEncoding.default,
                               headers: header)
            .validate(validate(_:_:_:))
            .responseData()
    }
    func deleteWithUrlParameters(fromURL url: String, parameters: Parameters?) -> Promise<Data> {
        guard NetworkReachabilityManager()?.isReachable ?? false else {
            return Promise(error: Errors.Remote.noNetworkConnectivity)
        }
        let url = baseUrl + url
        return session.request(url,
                               method: .delete,
                               parameters: parameters?.dictionary,
                               encoding: URLEncoding(destination: .queryString),
                               headers: header)
            .validate(validate(_:_:_:))
            .responseData()
    }
    func uploadFile(toURL url: String, file: Data, name: String, extention: String, mimeType: String, parameters: Parameters?) -> Promise<Data> {
        guard NetworkReachabilityManager()?.isReachable ?? false else {
            return Promise(error: Errors.Remote.noNetworkConnectivity)
        }
        let url = baseUrl + url
        return Promise { (resolve, rejct) in
            session
                .upload(multipartFormData: { multipartFormData in
                    multipartFormData.append(file,
                                             withName: name,
                                             fileName: name + extention,
                                             mimeType: mimeType)
                    if let parameter = parameters {
                    for (key, value) in parameter.dictionary {
                        multipartFormData.append(String(describing: value).data(using: .utf8)!, withName: key)
                        }
                        
                    }
                },
                        to: url,
                        method: .post,
                        headers: header,
                        encodingCompletion: { (result) in
                            switch result {
                            case .success(let upload, _, _):
                                upload
                                    .validate(self.validate(_:_:_:))
                                    .responseData { (response) in
                                        switch response.result {
                                        case .success(let data):
                                            resolve(data)
                                        case .failure(let error):
                                            rejct(error)
                                        }
                                }
                            case .failure(let error):
                                rejct(error)
                            }
                })
        }
    }
    
    
    func getNewTransactionId()->CUnsignedLongLong {
        if var newTransactionId = UserDefaults.standard.value(forKey: UserDefaultList.CurrentTransactionId.rawValue) as? CLongLong {
            newTransactionId = newTransactionId+1
            UserDefaults.standard.setValue(newTransactionId, forKey: UserDefaultList.CurrentTransactionId.rawValue)
            print(newTransactionId)
            return CUnsignedLongLong(newTransactionId)
            
        }
        UserDefaults.standard.setValue(1000, forKey: UserDefaultList.CurrentTransactionId.rawValue)
        return 1000
    }
    
    
}

class NetworkConfiguration {
    lazy var computedBaseURL: String = {
        let stringURL = "https://raw.githubusercontent.com/quickseries/mobile-test/master/data/"
        return stringURL
    }()
    var baseUrl: String {
        return computedBaseURL
    }
    var token: String? {
        return UserDefaultsService.shared.getToken()
    }
    var header: HTTPHeaders? {
        var result: HTTPHeaders? = [
            "Content-Type": "text/plain"
        ]
        if let token = token {
            result?.updateValue(token, forKey: "Authorization")
        }
        result?.updateValue("B2B", forKey: "app-type")
        result?.updateValue("IOS", forKey: "os-type")
        if let version = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String {
            result?.updateValue(version, forKey: "app-version")
        }
        return result
    }
    lazy var session: SessionManager = {
        let sessionConfig = URLSessionConfiguration.default
        sessionConfig.timeoutIntervalForRequest = 60
        let session = SessionManager(configuration: sessionConfig)
        return session
    }()
    func validate(_ request: URLRequest?, _ response: HTTPURLResponse, _ data: Data?) -> Request.ValidationResult {
        
        switch response.statusCode {
        case 400:
            return .failure(Errors.Remote.badRequest(data: data))
        case 401:
            // remove token and show authentication page
            UserDefaultsService.shared.removeToken()
            DispatchQueue.main.async {
                if let appDelegate = UIApplication.shared.delegate as? AppDelegate {
                    let root = UIStoryboard(name: "Intro", bundle: Bundle.main).instantiateInitialViewController()
                    let newWindow = UIWindow()
//                    appDelegate.replaceWindow(newWindow)
                    newWindow.rootViewController = root
                    debugPrint(appDelegate)
                }
            }
            return .failure(Errors.Remote.unAuthorized(data: data))
        case 403:
            return .failure(Errors.Remote.forbiden)
        case 404:
            return .failure(Errors.Remote.notFound(data: data))
        case 400..<500:
            return .failure(Errors.Remote.serverUnAvailable)
        case 503:
            return .failure(Errors.Remote.maintenance)
        case 504:
            return .failure(Errors.Remote.serverUnAvailable)
        case 500 ..< 600:
            return .failure(Errors.Remote.notFound(data: data))
        default:
            return .success
        }

    }
}

extension HttpGateway{

func getStatusMessage(state: Int) -> String {
    var result = ""
    switch state
    {
    case 0           :  result = "ÙÙÙÙ"
    case 1...99999   : result = " Ø®Ø·Ø§Û Ø¯Ø± ØªØ±Ø§Ú©ÙØ´ Ø¹ÙÙÛØ§ØªÛ"
    case 1002102     :  result = "Ø®Ø·Ø§ Ø¯Ø± Ø³Ø±ÙØ± Ø¨Ø§ÙÚ©"
    case 1002101     : result = "Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù Ø¨Ù Ø³Ø±ÙØ± Ø¨Ø§ÙÚ©"
    case 1001702     :  result = "Ø¨Ø¯ÙÛÙ Ú¯Ø°Ø´Øª Ø²ÙØ§ÙØ Ø§ÙÚ©Ø§Ù Ø¨Ø§Ø²ÛØ§Ø¨Û ØªØ±Ø§Ú©ÙØ´ ÙØ¬ÙØ¯ ÙØ¯Ø§Ø±Ø¯"
    case 1001701     :  result = "ØªØ±Ø§Ú©ÙØ´ ÛØ§ÙØª ÙØ´Ø¯"
    case 1001611     :  result = "ÙØ¨ÙØº Ø¯Ø± ÙØ­Ø¯ÙØ¯Ù ÙØ¬Ø§Ø² ÙÙÛ Ø¨Ø§Ø´Ø¯"
    case 1001603     :  result = "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛØ§ÙØª ÙÛØ³Øª Ø­Ø³Ø§Ø¨ ÙØ§ ÛØ§ Ú©Ø§Ø±Øª ÙØ§"
    case 1001602     :  result = "Ø­Ø³Ø§Ø¨ ÛØ§ Ú©Ø§Ø±Øª ØºÛØ±ÙØ¹Ø§Ù Ø´Ø¯Ù Ø§Ø³Øª"
    case 1001601     :  result = "Ø´ÙØ§Ø±Ù Ø­Ø³Ø§Ø¨ ÛØ§ Ú©Ø§Ø±Øª ÙØ¹ØªØ¨Ø± ÙÛØ³Øª"
    case 1001505     :  result = "Ø±ÙØ² ÙØ¹Ø§Ù Ø³Ø§Ø²Û ØµØ­ÛØ­ ÙÙÛ Ø¨Ø§Ø´Ø¯ "
    case 1001504     :  result = "Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø±Û ØºÛØ±ÙØ¹Ø§Ù Ø´Ø¯Ù Ø§Ø³Øª"
    case 1001503     :  result = "ØªØ¹Ø¯Ø§Ø¯ Ø±ÙØ²ÙØ§Û ØºÙØ· Ø¨ÛØ´ØªØ± Ø§Ø² Ø­Ø¯ ÙØ¬Ø§Ø² Ø§Ø³Øª"
    case 1001502     :  result = "ÙØ´Ø³Øª ÙØ¹ØªØ¨Ø± ÙÛØ³Øª"
    case 1001501     :  result = "ÙØ§Ù Ú©Ø§Ø±Ø¨Ø±Û ÛØ§ Ø±ÙØ² Ø¹Ø¨ÙØ± ØµØ­ÛØ­ ÙÛØ³Øª"
    case 1001403     :  result = "Ø¨Ø±ÙØ§ÙÙ ÙÛØ§Ø² Ø¨Ù ØªØ§ÛÛØ¯ ÙÙÛØª ÙØ¬Ø¯Ø¯ Ú©Ø§Ø±Ø¨Ø± Ø¯Ø§Ø±Ø¯"
    case 1001402     :  result = "Ø±ÙØ² ÙØ±ÙØ¯ Ø§ÙØªØ®Ø§Ø¨ Ø´Ø¯Ù ØªÙØ³Ø· Ú©Ø§Ø±Ø¨Ø± ÙØ§Ø¨Ù ÙØ¨ÙÙ ÙÛØ³Øª"
    case 1001401     :  result = "ÙÙØ¨Ø§ÛÙ ÙØ¨ÙØ§ ÙØ¹Ø§Ù Ø´Ø¯Ù Ø§Ø³Øª"
    case 1001303     :  result = "Ø²ÙØ§Ù ÙØ§Ø²Ù Ø¨Ø±Ø§Û Ø§Ø±Ø³Ø§Ù ÙØ¬Ø¯Ø¯ Ú©Ø¯ ÙØ¹Ø§Ù Ø³Ø§Ø²Û Ú¯Ø°Ø´ØªÙ Ø§Ø³Øª"
    case 1001302     :  result = "ÙÛØ§Ø² Ø¨Ù Ø§Ø±Ø³Ø§Ù ÙØ¬Ø¯Ø¯ Ú©Ø¯ ÙØ¹Ø§Ù Ø³Ø§Ø²Û ÙÙØ¨Ø§ÛÙ (Ø¯Ø± ØµÙØ±Øª ØºÙØ· Ø¨ÙØ¯Ù Ø±ÙØ² ÛØ§ ØªØ§ÛÙ Ø§ÙØª Ø´Ø¯Ù Ú©Ø¯ ÙØ¹Ø§Ù Ø³Ø§Ø²Û)"
    case 1001301     :  result = "Ú©Ø¯ ÙØ¹Ø§Ù Ø³Ø§Ø²Û Ø§Ø±Ø³Ø§ÙÛ ØµØ­ÛØ­ ÙÛØ³Øª"
    case 1001203     :  result = "ÙØ³Ø®Ù Ø¨Ø±ÙØ§ÙÙ ÙØ¯ÛÙÛ Ø¨ÙØ¯Ù Ù Ø¨Ù Ø±ÙØ²Ø±Ø³Ø§ÙÛ Ø¢Ù Ø§ÙØ²Ø§ÙÛ ÙÛØ³Øª"
    case 1001202     :  result = "the State Application is Worm"
    case 1001201     :  result = "Ø¨Ø±ÙØ§ÙÙ ØºÛØ± ÙØ¹Ø§Ù Ø´Ø¯Ù Ø§Ø³Øª"
    case 1001103     :  result = "ÙÛØ§Ø² Ø¨Ù ØªØ§ÛÛØ¯ Ø´ÙØ§Ø±Ù ÙÙØ¨Ø§ÛÙ ÙØ¬ÙØ¯ Ø¯Ø§Ø±Ø¯"
    case 1001102     :  result = "ÙÙØ¨Ø§ÛÙ ØºÛØ±ÙØ¹Ø§Ù Ø´Ø¯Ù Ø§Ø³Øª"
    case 1001101     :  result = "ÙÙØ¨Ø§ÛÙ ÛØ§ÙØª ÙØ´Ø¯"
    case 1000301     :  result = "Call ID of Notification not Found "
    case 1000202     :  result = "Ú©ÙØ¨ÙØ¯ ÙÙØ§Ø¨Ø¹ Ù¾Ø±Ø¯Ø§Ø²Ø´Û Ø¨Ø± Ø±ÙÛ Ø³Ø±ÙØ± (Ú©ÙÛ Ø¨Ø¹Ø¯ Ø³Ø¹Û Ú©ÙÛØ¯)"
    case 1000201     :  result = "Ø®Ø·Ø§Û ÙØ§ ÙØ´Ø®Øµ"
    case 1000200     :  result = "Ø®Ø·Ø§Û Ø¯Ø§Ø®ÙÛ Ø³Ø±ÙØ±"
    case 1000104     :  result = "Ø²ÙØ§Ù ÙÚ¯ÙØ¯Ø§Ø±Û Ø³Ø±ÙØ±"
    case 1000103     :  result = "Ø²ÙØ§Ù Ø§Ø±Ø³Ø§ÙÛ Ø¯Ø±Ø®ÙØ§Ø³Øª Ø¨Ø§ Ø²ÙØ§Ù Ø³Ø±ÙØ±ÙÙÚ¯Ø§Ù ÙÛØ³Øª"
    case 1000102     :  result = "Ø¯Ø±Ø®ÙØ§Ø³Øª ÙØ§ÙØ¹ØªØ¨Ø±ÙÛ Ø¨Ø§Ø´Ø¯"
    case 1000101     :  result = "ÙØªÛØ¬Ù ØªØ±Ø§Ú©ÙØ´ ÙØ§ÙØ´Ø®Øµ ÙÛ Ø¨Ø§Ø´Ø¯"
        
    default :  result = " Ø®Ø·Ø§Û Ø¯Ø± ØªØ±Ø§Ú©ÙØ´ Ø¹ÙÙÛØ§ØªÛ"
    }
    
    return result
}
}
